{
    "vertShader": [
        "#version 300 es",
        "in vec3 vertexPosition;",
        "in vec3 vertexNormal;",
        "in vec2 vertexUV;",
        "\n",
        "uniform mat4 uProjectionMatrix;",
        "uniform mat4 uViewMatrix;",
        "uniform mat4 uModelMatrix;",
        "uniform mat4 normalMatrix;",
        "uniform vec3 uCameraPosition;",
        "\n",
        "out vec3 oFragPosition;",
        "out vec3 oNormal;",
        "out vec3 normalInterp;",
        "out vec3 oCamPosition;",
        "out vec2 oUV;",
        "\n",
        "void main() {",
        "\n",
        "    oCamPosition = (uViewMatrix * vec4(uCameraPosition, 1.0)).xyz;",
        "    oFragPosition = (uModelMatrix * vec4(vertexPosition, 1.0)).xyz;",
        "    oNormal = normalize((uModelMatrix * vec4(vertexNormal, 1.0)).xyz);",
        "    normalInterp = vec3(normalMatrix * vec4(vertexNormal, 0.0));",
        "    oUV = -vertexUV;",
        "    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(vertexPosition, 1.0);",
        "}"
    ],
    "attribs": [
        "vertexPosition",
        "vertexNormal",
        "vertexUV"
    ],
    "uniforms": [
        "uProjectionMatrix",
        "uViewMatrix",
        "uModelMatrix",
        "normalMatrix",
        "uCameraPosition",
        "numPointLights",
        "diffuseVal",
        "ambientVal",
        "numDirLights",
        "specularVal",
        "nVal",
        "alpha",
        "uTexture"
    ],
    "fragShader": [
        "#version 300 es",
        "#define MAX_DIR_LIGHTS 10",
        "#define MAX_POINT_LIGHTS 50",
        "precision highp float;",
        "struct PointLight {",
        "   vec3 position;",
        "   vec3 color;",
        "   float strength;",
        "   float constant;",
        "   float linear;",
        "   float quadratic;",
        "};",
        "\n",
        "struct DirectionalLight {",
        "   vec3 position;",
        "   vec3 color;",
        "   vec3 direction;",
        "};",
        "\n",
        "in vec3 oFragPosition;",
        "in vec3 oNormal;",
        "in vec3 normalInterp;",
        "in vec3 oCamPosition;",
        "in vec2 oUV;",
        "\n",
        "uniform int numPointLights;",
        "uniform vec3 diffuseVal;",
        "uniform vec3 ambientVal;",
        "uniform int numDirLights;",
        "uniform vec3 specularVal;",
        "uniform float nVal;",
        "uniform float alpha;",
        "uniform sampler2D uTexture;",
        "uniform PointLight pointLights[MAX_POINT_LIGHTS];",
        "uniform DirectionalLight directionalLights[MAX_DIR_LIGHTS];",
        "\n",
        "out vec4 fragColor;",
        "\n",
        "vec3 CalcDirLight(DirectionalLight light, vec3 normal, vec3 viewDir)",
        "{",
        "   vec3 lightDir = normalize(-light.direction);",
        "   float diff = max(dot(normal, lightDir), 1.0);",
        "   vec3 reflectDir = reflect(-lightDir, normal);",
        "   float spec = pow(max(dot(viewDir, reflectDir), 0.0), nVal);",
        "   vec3 ambient = light.color * ambientVal * diffuseVal * vec3(texture(uTexture, oUV));",
        "   vec3 diffuse = light.color  * diff * diffuseVal * vec3(texture(uTexture, oUV));",
        "   vec3 specular = vec3(0,0,0);",
        "\n",
        "   specular = light.color * specularVal * spec * vec3(texture(uTexture, oUV));",
        "   return (ambient + diffuse + specular);",
        "}",
        "\n",
        "vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)",
        "{",
        "   vec4 texColor = texture(uTexture, oUV);",
        "   vec3 lightDir = normalize(light.position - fragPos);",
        "   float diff = max(dot(normal, lightDir), 1.0);",
        "   vec3 reflectDir = reflect(-lightDir, normal);",
        "   float spec = pow(max(dot(viewDir, reflectDir), 0.0), nVal);",
        "   float distance = length(light.position - fragPos);",
        "   float attenuation = light.strength / (light.constant + light.linear * distance + light.quadratic * (distance * distance));",
        "   vec3 ambient = ambientVal * texColor.xyz;",
        "   vec3 diffuse = light.color  * diff * diffuseVal * texColor.xyz;",
        "   vec3 specular = vec3(0,0,0);",
        "\n",
        "   specular = light.color * specularVal * spec * texColor.xyz;",
        "   specular *= attenuation;",
        "   ambient *= attenuation;",
        "   diffuse *= attenuation;",

        "   return (ambient + diffuse + specular);",
        "}",
        "\n",
        "void main() {",
        "    vec3 normal = normalize(normalInterp);",
        "    vec3 result = vec3(0,0,0);",
        "    vec3 viewDir = normalize(oCamPosition - oFragPosition);",
        "\n",
        "    for (int i = 0; i < numPointLights; i++) {",
        "       result += CalcPointLight(pointLights[i], normal, oFragPosition, viewDir);",
        "    }",
        "   for (int j = 0; j < numDirLights; j++) {",
        "       result += CalcDirLight(directionalLights[j], normal, viewDir);",
        "   }",
        "   vec4 texColor = texture(uTexture, oUV);",
        "   if (texColor.w < 0.1) { //check if the alpha of the texture is below 0.1 then dont render it",
        "       discard;",
        "   }",
        "\n",
        "   fragColor = vec4(result, alpha);",
        "\n",
        "}"
    ]
}