{
    "vertShader": [
        "#version 300 es",
        "in vec3 vertexPosition;",
        "in vec3 vertexNormal;",
        "in vec2 vertexUV;",
        "\n",
        "uniform mat4 uProjectionMatrix;",
        "uniform mat4 uViewMatrix;",
        "uniform mat4 uModelMatrix;",
        "uniform mat4 normalMatrix;",
        "\n",
        "out vec3 oFragPosition;",
        "out vec3 oNormal;",
        "out vec3 normalInterp;",
        "out vec2 oUV;",
        "\n",
        "void main() {",
        "    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(vertexPosition, 1.0);",
        "\n",
        "    oFragPosition = (uModelMatrix * vec4(vertexPosition, 1.0)).xyz;",
        "    oNormal = normalize((uModelMatrix * vec4(vertexNormal, 1.0)).xyz);",
        "    normalInterp = vec3(normalMatrix * vec4(vertexNormal, 0.0));",
        "    oUV = vertexUV;",
        "}"
    ],
    "attribs": [
        "vertexPosition",
        "vertexNormal",
        "vertexUV"
    ],
    "uniforms": [
        "uProjectionMatrix",
        "uViewMatrix",
        "uModelMatrix",
        "normalMatrix",
        "uCameraPosition",
        "numLights",
        "diffuseVal",
        "ambientVal",
        "specularVal",
        "nVal",
        "uTexture"
    ],
    "fragShader": [
        "#version 300 es",
        "#define MAX_LIGHTS 128",
        "precision highp float;",
        "struct PointLight {",
        "   vec3 position;",
        "   vec3 color;",
        "   float strength;",
        "   float constant;",
        "   float linear;",
        "   float quadratic;",
        "};",
        "\n",
        "in vec3 oFragPosition;",
        "in vec3 oNormal;",
        "in vec3 normalInterp;",
        "in vec2 oUV;",
        "\n",
        "uniform vec3 uCameraPosition;",
        "uniform int numLights;",
        "uniform vec3 diffuseVal;",
        "uniform vec3 ambientVal;",
        "uniform vec3 specularVal;",
        "uniform float nVal;",
        "uniform sampler2D uTexture;",
        "uniform PointLight pointLights[MAX_LIGHTS];",
        "\n",
        "out vec4 fragColor;",
        "\n",
        "vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)",
        "{",
        "   vec3 lightDir = normalize(light.position - fragPos);",
        "   float diff = max(dot(normal, lightDir), 0.0);",
        "   vec3 reflectDir = reflect(-lightDir, normal);",
        "   float spec = pow(max(dot(viewDir, reflectDir), 0.0), nVal);",
        "   float distance = length(light.position - fragPos);",
        "   float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));",
        "   vec3 ambient = light.color * ambientVal * vec3(texture(uTexture, oUV));",
        "   vec3 diffuse = light.color  * diff * diffuseVal * vec3(texture(uTexture, oUV));",
        "   vec3 specular = vec3(0,0,0);",
        "\n",
        "   if (diff > 0.0f) {",
        "       specular = light.color * specularVal * spec * vec3(texture(uTexture, oUV));",
        "       specular *= attenuation;",
        "   }",
        "   ambient *= attenuation;",
        "   diffuse *= attenuation;",
        "   return (ambient + diffuse + specular);",
        "}",
        "\n",
        "void main() {",
        "    vec3 normal = normalize(normalInterp);",
        "    vec3 result = vec3(0,0,0);",
        "    vec3 viewDir = normalize(uCameraPosition - oFragPosition);",
        "\n",
        "    for (int i = 0; i < numLights; i++) {",
        "       result += CalcPointLight(pointLights[i], normal, oFragPosition, viewDir);",
        "    }",
        "\n",
        "   fragColor = vec4(result, 1.0);",
        "\n",
        "}"
    ]
}