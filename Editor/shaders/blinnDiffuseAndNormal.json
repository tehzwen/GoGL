{
    "vertShader": [
        "#version 300 es",
        "in vec3 vertexPosition;",
        "in vec3 vertexNormal;",
        "in vec2 vertexUV;",
        "in vec3 vertexBitangent;",
        "\n",
        "uniform mat4 normalMatrix;",
        "uniform mat4 uProjectionMatrix;",
        "uniform mat4 uViewMatrix;",
        "uniform mat4 uModelMatrix;",
        "uniform vec3 uCameraPosition;",
        "\n",
        "out vec3 oFragPosition;",
        "out vec3 oNormal;",
        "out vec3 oCamPosition;",
        "out vec2 oUV;",
        "out vec3 oVertBitang;",
        "out vec3 normalInterp;",
        "\n",
        "void main() {",
        "\n",
        "    oFragPosition = (uModelMatrix * vec4(vertexPosition, 1.0)).xyz;",
        "    oNormal = normalize((uModelMatrix * vec4(vertexNormal, 1.0)).xyz);",
        "    oUV = vertexUV;",
        "    oVertBitang = vertexBitangent;",
        "    normalInterp = vec3(normalMatrix * vec4(vertexNormal, 0.0));",
        "    oCamPosition = (vec4(uCameraPosition, 1.0) * uViewMatrix).xyz;",
        "    gl_Position = uProjectionMatrix * uViewMatrix * vec4(oFragPosition, 1.0);",
        "}"
    ],
    "attribs": [
        "vertexPosition",
        "vertexNormal",
        "vertexUV",
        "vertexBitangent"
    ],
    "uniforms": [
        "uProjectionMatrix",
        "uViewMatrix",
        "uModelMatrix",
        "uCameraPosition",
        "normalMatrix",
        "numPointLights",
        "numDirLights",
        "diffuseVal",
        "ambientVal",
        "specularVal",
        "nVal",
        "uTexture",
        "uTextureNorm"
    ],
    "fragShader": [
        "#version 300 es",
        "#define MAX_DIR_LIGHTS 10",
        "#define MAX_POINT_LIGHTS 50",
        "precision highp float;",
        "struct PointLight {",
        "   vec3 position;",
        "   vec3 color;",
        "   float strength;",
        "   float constant;",
        "   float linear;",
        "   float quadratic;",
        "};",
        "\n",
        "struct DirectionalLight {",
        "   vec3 position;",
        "   vec3 color;",
        "   vec3 direction;",
        "};",
        "\n",
        "in vec3 oFragPosition;",
        "in vec3 oNormal;",
        "in vec2 oUV;",
        "in vec3 oVertBitang;",
        "in vec3 oCamPosition;",
        "in vec3 normalInterp;",
        "\n",
        "uniform vec3 uCameraPosition;",
        "uniform int numDirLights;",
        "uniform int numPointLights;",
        "uniform vec3 diffuseVal;",
        "uniform vec3 ambientVal;",
        "uniform vec3 specularVal;",
        "uniform vec3 uReverseLightDirection;",
        "uniform float nVal;",
        "uniform sampler2D uTexture;",
        "uniform sampler2D uTextureNorm;",
        "uniform PointLight pointLights[MAX_POINT_LIGHTS];",
        "uniform DirectionalLight directionalLights[MAX_DIR_LIGHTS];",
        "\n",
        "out vec4 fragColor;",
        "\n",
        "vec3 CalcDirLight(DirectionalLight light, vec3 normal, vec3 viewDir)",
        "{",
        "   vec3 lightDir = normalize(-light.direction);",
        "   float diff = max(dot(normal, lightDir), 1.0);",
        "   vec3 reflectDir = reflect(normal, lightDir);",
        "   float spec = pow(max(dot(-viewDir, reflectDir), 0.0), nVal);",
        "   vec3 ambient = ambientVal * vec3(texture(uTexture, oUV)) / vec3(5);",
        "   vec3 diffuse = light.color * diff * diffuseVal * vec3(texture(uTexture, oUV));",
        "   vec3 specular = vec3(0,0,0);",
        "\n",
        "   specular = light.color * specularVal * spec * vec3(texture(uTexture, oUV));",
        "   return (specular + diffuse + ambient);",
        "}",
        "\n",
        "vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)",
        "{",
        "   vec3 lightDir = normalize(light.position - fragPos);",
        "   float diff = max(dot(normal, lightDir), 1.0);",
        "   vec3 reflectDir = reflect(-lightDir, normal);",
        "   float spec = pow(max(dot(viewDir, reflectDir), 0.0), nVal);",
        "   float distance = length(light.position - fragPos);",
        "   float attenuation = light.strength / (light.constant + light.linear * distance + light.quadratic * (distance * distance));",
        "   vec3 ambient = light.color * ambientVal * diffuseVal * vec3(texture(uTexture, oUV));",
        "   vec3 diffuse = light.color  * diff * diffuseVal * vec3(texture(uTexture, oUV));",
        "   vec3 specular = vec3(0,0,0);",
        "\n",
        "   specular = light.color * specularVal * spec * vec3(texture(uTexture, oUV));",
        "   specular *= attenuation;",
        "   ambient *= attenuation;",
        "   //diffuse *= attenuation;",
        "   return (ambient + diffuse + specular);",
        "}",
        "\n",
        "void main() {",
        "    vec3 result = vec3(0,0,0);",
        "    vec3 viewDir = normalize(oCamPosition - oFragPosition);",
        "\n",
        "    float shadow;",
        "    vec3 normal = texture(uTextureNorm, oUV).xyz;",
        "    normal = 2.0 * normal - 1.0;",
        "    normal = normal * vec3(5.0, 5.0, 5.0);",
        "    vec3 biTangent = cross(oNormal, oVertBitang);",
        "    mat3 nMatrix = mat3(oVertBitang, biTangent, oNormal);",
        "    normal = normalize(nMatrix * normal);",
        "    normal = normal * normalInterp;",
        "\n",
        "   for (int j = 0; j < numDirLights; j++) {",
        "       vec3 lightDir = normalize(directionalLights[j].position - oFragPosition);",
        "       result += CalcDirLight(directionalLights[j], normal, viewDir);",
        "   }",
        "\n",
        "    for (int i = 0; i < numPointLights; i++) {",
        "       result += CalcPointLight(pointLights[i], normal, oFragPosition, viewDir);",
        "    }",
        "\n",
        "   fragColor = vec4(result, 1.0);",
        "\n",
        "}"
    ]
}