{
    "vertShader": [
        "#version 300 es",
        "layout (location = 0) in vec3 vertexPosition;",
        "layout (location = 1) in vec3 vertexNormal;",
        "uniform mat4 uProjectionMatrix;",
        "uniform mat4 uViewMatrix;",
        "uniform mat4 uModelMatrix;",
        "uniform mat4 normalMatrix;",
        "uniform vec3 uCameraPosition;",
        "uniform mat4 textureMatrix;",
        "out vec3 oCamPosition;",
        "out vec3 oFragPosition;",
        "out vec3 oNormal;",
        "out vec3 normalInterp;",
        "void main() {",
        "    oCamPosition = (uViewMatrix * vec4(uCameraPosition, 1.0)).xyz;",
        "    oFragPosition = (uModelMatrix * vec4(vertexPosition, 1.0)).xyz;",
        "    oNormal = normalize((uModelMatrix * vec4(vertexNormal, 1.0)).xyz);",
        "    normalInterp = vec3(normalMatrix * vec4(vertexNormal, 0.0));",
        "    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(vertexPosition, 1.0);",
        "}"
    ],
    "attribs": [
        "vertexPosition",
        "vertexNormal"
    ],
    "uniforms": [
        "uProjectionMatrix",
        "uViewMatrix",
        "uModelMatrix",
        "normalMatrix",
        "uCameraPosition",
        "numPointLights",
        "numDirLights",
        "diffuseVal",
        "ambientVal",
        "specularVal",
        "alpha",
        "nVal"
    ],
    "fragShader": [
        "#version 300 es",
        "#define MAX_DIR_LIGHTS 10",
        "#define MAX_POINT_LIGHTS 50",
        "precision highp float;",
        "struct PointLight {",
        "   vec3 position;",
        "   vec3 color;",
        "   float strength;",
        "   float constant;",
        "   float linear;",
        "   float quadratic;",
        "};",
        "\n",
        "struct DirectionalLight {",
        "   vec3 position;",
        "   vec3 color;",
        "   vec3 direction;",
        "};",
        "\n",
        "in vec3 oFragPosition;",
        "in vec3 oNormal;",
        "in vec3 normalInterp;",
        "in vec3 oCamPosition;",
        "\n",
        "uniform int numPointLights;",
        "uniform int numDirLights;",
        "uniform vec3 diffuseVal;",
        "uniform vec3 ambientVal;",
        "uniform vec3 specularVal;",
        "uniform float nVal;",
        "uniform float alpha;",
        "uniform PointLight pointLights[MAX_POINT_LIGHTS];",
        "uniform DirectionalLight directionalLights[MAX_DIR_LIGHTS];",
        "\n",
        "out vec4 fragColor;",
        "\n",
        "vec3 CalcDirLight(DirectionalLight light, vec3 normal, vec3 viewDir)",
        "{",
        "   vec3 lightDir = normalize(-light.direction);",
        "   float diff = max(dot(normal, lightDir), 0.0);",
        "   vec3 reflectDir = reflect(-lightDir, normal);",
        "   float spec = pow(max(dot(viewDir, reflectDir), 0.0), nVal);",
        "   vec3 ambient = light.color * ambientVal * diffuseVal;",
        "   vec3 diffuse = light.color  * diff * diffuseVal;",
        "   vec3 specular = vec3(0,0,0);",
        "\n",
        "   specular = light.color * specularVal * spec;",
        "   return (ambient + diffuse + specular);",
        "}",
        "\n",
        "vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)",
        "{",
        "   vec3 lightDir = normalize(light.position - fragPos);",
        "   float diff = max(dot(normal, lightDir), 0.0);",
        "   vec3 reflectDir = reflect(-lightDir, normal);",
        "   float spec = pow(max(dot(viewDir, reflectDir), 0.0), nVal);",
        "   float distance = length(light.position - fragPos);",
        "   float attenuation = light.strength / (light.constant + light.linear * distance + light.quadratic * (distance * distance));",
        "   vec3 ambient = light.color * ambientVal * diffuseVal;",
        "   vec3 diffuse = light.color  * diff * diffuseVal;",
        "   vec3 specular = vec3(0,0,0);",
        "\n",
        "   if (diff < 0.0f) {",
        "       specular = light.color * specularVal * spec;",
        "       specular *= attenuation;",
        "   }",
        "   ambient *= attenuation;",
        "   diffuse *= attenuation;",
        "   return (ambient + diffuse + specular);",
        "}",
        "\n",
        "void main() {",
        "    float bias = -0.006;",
        "    vec3 normal = normalize(normalInterp);",
        "    vec3 result = vec3(0,0,0);",
        "    vec3 viewDir = normalize(oCamPosition - oFragPosition);",
        "    for (int i = 0; i < numPointLights; i++) {",
        "       result += CalcPointLight(pointLights[i], normal, oFragPosition, viewDir);",
        "    }",
        "\n",
        "   for (int j = 0; j < numDirLights; j++) {",
        "       result += CalcDirLight(directionalLights[j], normal, viewDir);",
        "   }",
        
        "   fragColor = vec4(result, alpha);",
        "    //fragColor = vec4(vec3(depthValue), 1.0);",
        "    //fragColor = vec4(projTexcoord, 1.0);",
        "}"
    ]
}